import React, { useRef, useState, useEffect, useCallback } from 'react';
import {
  SafeAreaView,
  View,
  Text,
  StyleSheet,
  FlatList,
  TextInput,
  Image,
  TouchableOpacity,
  Keyboard,
  Animated,
  Platform,
  TouchableWithoutFeedback,
  BackHandler,
  KeyboardAvoidingView,
} from 'react-native';
import { useLocalSearchParams, useFocusEffect, useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import Header from '../components/Header';
import { supabase } from "../../supabase/supabaseClient";
import io from 'socket.io-client';

const API_BASE = "http://192.168.100.83:3000/api";
const API_ORIGIN = API_BASE.replace(/\/api$/, "");
const INPUT_BAR_BASE_HEIGHT = 56; // approximate input bar height

const ViewMessageScreen = () => {
  const { conversationId, name: initialName } = useLocalSearchParams();
  const router = useRouter();
  const flatListRef = useRef(null);
  const [messages, setMessages] = useState([]);
  const [inputText, setInputText] = useState('');
  const [inputHeight, setInputHeight] = useState(40);
  const [loading, setLoading] = useState(true);
  const [meId, setMeId] = useState(null);
  const [partnerId, setPartnerId] = useState(null);
  const [partnerName, setPartnerName] = useState(initialName || '');
  const [partnerAvatar, setPartnerAvatar] = useState(null);
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const insets = useSafeAreaInsets();
  const keyboardHeight = useRef(new Animated.Value(0)).current;

  const formatTitle = (name) => {
    if (!name) return 'Message';
    const tokens = String(name).trim().split(/\s+/);
    if (tokens.length <= 2) return name;
    return `${tokens.slice(0, 2).join(' ')}...`;
  };

  // Ensure Android hardware back goes to messages list
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        router.replace('/(drawer)/messages');
        return true; // consume the event
      };
      const sub = BackHandler.addEventListener('hardwareBackPress', onBackPress);
      return () => sub.remove();
    }, [router])
  );

  useEffect(() => {
    if (Platform.OS === 'android') {
      const showSub = Keyboard.addListener('keyboardDidShow', (e) => {
        Animated.timing(keyboardHeight, {
          toValue: e.endCoordinates.height,
          duration: 250,
          useNativeDriver: false,
        }).start();
      });
      const hideSub = Keyboard.addListener('keyboardDidHide', () => {
        Animated.timing(keyboardHeight, {
          toValue: 0,
          duration: 250,
          useNativeDriver: false,
        }).start();
      });

      return () => {
        showSub.remove();
        hideSub.remove();
      };
    }
  }, []);

  const renderItem = useCallback(({ item }) => {
    const isMe = item.sender === 'me';
    const avatarUri = !isMe ? (item.avatar || partnerAvatar) : null;
    const avatarSource = typeof avatarUri === 'string' ? { uri: avatarUri } : avatarUri;
    const timeLabel = item.createdAt ? new Date(item.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';
    return (
      <View
        style={[
          styles.messageRow,
          isMe ? styles.rightAlign : styles.leftAlign,
        ]}
      >
        {!isMe && !!avatarSource && <Image source={avatarSource} style={styles.avatar} />}
        <View
          style={[
            styles.bubble,
            isMe ? styles.myBubble : styles.otherBubble,
          ]}
        >
          <Text style={isMe ? styles.myMessageText : styles.messageText}>
            {item.text}
          </Text>
          {!!timeLabel && (
            <Text style={isMe ? styles.myTimestamp : styles.timestamp}>{timeLabel}</Text>
          )}
        </View>
      </View>
    );
  }, [partnerAvatar]);

  const resolveUrl = (u) => (!u ? null : (String(u).startsWith('http') ? String(u) : `${API_ORIGIN}${u}`));

  const loadSession = async () => {
    const { data } = await supabase.auth.getSession();
    const at = data?.session?.access_token || null;
    const rt = data?.session?.refresh_token || null;
    const uid = data?.session?.user?.id || null;
    setAccessToken(at);
    setRefreshToken(rt);
    setMeId(uid);
    return { at, rt, uid };
  };

  const fetchConversationMeta = async (at, rt) => {
    try {
      const res = await fetch(`${API_BASE}/message/getConversation`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json', 'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}` },
      });
      if (!res.ok) return;
      const json = await res.json();
      const list = Array.isArray(json?.conversations) ? json.conversations : [];
      const found = list.find(c => String(c.conversationId) === String(conversationId));
      if (found) {
        const other = found.otherUser || {};
        const nameParts = [other.firstName, other.middleName, other.lastName].filter(Boolean);
        const displayName = (nameParts.join(' ') || other.username || 'User').trim();
        setPartnerId(other.id || null);
        setPartnerName(displayName);
        setPartnerAvatar(resolveUrl(other.profilePicture));
      }
    } catch {}
  };

  const fetchMessages = async (at, rt, uid) => {
    if (!conversationId) return;
    try {
      const res = await fetch(`${API_BASE}/message/getConversation/${encodeURIComponent(conversationId)}`, {
        method: 'GET',
        headers: { 'Content-Type': 'application/json', 'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}` },
      });
      if (!res.ok) return;
      const json = await res.json();
      const rows = Array.isArray(json?.messages) ? json.messages : [];
      const effectiveUid = uid || meId;
      const mapped = rows.map((m) => {
        const isMe = m.senderId === effectiveUid;
        return {
          id: m.id || m.messageId || String(m.created_at || Math.random()),
          text: m.content || '',
          sender: isMe ? 'me' : 'other',
          avatar: isMe ? null : partnerAvatar,
          createdAt: m.created_at || null,
        };
      });
      setMessages(mapped);
    } catch (e) {
      setMessages([]);
    }
  };

  const markRead = async (at, rt) => {
    if (!conversationId) return;
    try {
      await fetch(`${API_BASE}/message/markRead/${encodeURIComponent(conversationId)}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}` },
      });
    } catch {}
  };

  const refreshAll = async () => {
    setLoading(true);
    try {
      const { at, rt, uid } = await loadSession();
      await Promise.all([
        fetchConversationMeta(at, rt),
        fetchMessages(at, rt, uid),
      ]);
      // Fire-and-forget mark as read to avoid blocking UI
      markRead(at, rt);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    // Clear previous conversation immediately to avoid showing old messages
    setMessages([]);
    setPartnerId(null);
    setPartnerName(initialName || '');
    setPartnerAvatar(null);
    refreshAll();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [conversationId]);

  // Realtime via Socket.IO: join user room and listen for new messages
  useEffect(() => {
    let socket;
    let mounted = true;
    const setup = async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const uid = data?.session?.user?.id;
        if (!uid) return;
        socket = io(API_ORIGIN, { transports: ['websocket'], withCredentials: true });
        socket.on('connect', () => {
          socket.emit('join', uid);
        });
        // When a new message arrives
        socket.on('message:new', (payload) => {
          try {
            if (!mounted) return;
            if (!payload) return;
            const cid = String(payload.conversationId || '');
            if (String(conversationId) !== cid) return;
            const m = payload.message || payload;
            const isMe = m.senderId === (meId || uid);
            setMessages(prev => ([
              ...prev,
              {
                id: m.id || String(Date.now()),
                text: m.content || '',
                sender: isMe ? 'me' : 'other',
                avatar: isMe ? null : (m.senderAvatar || partnerAvatar),
                createdAt: m.createdAt || m.created_at || new Date().toISOString(),
              }
            ]));
          } catch {}
        });
        // If a remote update indicates we should refetch
        socket.on('conversation:updated', (payload) => {
          try {
            if (!mounted) return;
            const cid = String(payload?.conversationId || '');
            if (String(conversationId) !== cid) return;
            // Soft refresh to ensure ordering/read status
            (async () => {
              const { at, rt, uid: u } = await loadSession();
              await fetchMessages(at, rt, u);
            })();
          } catch {}
        });
      } catch {}
    };
    setup();
    return () => {
      mounted = false;
      try { if (socket) { socket.removeAllListeners(); socket.disconnect(); } } catch {}
    };
  }, [API_ORIGIN, conversationId, partnerAvatar, meId]);

  // Always keep scrolled to latest when messages change (single source of truth)
  useEffect(() => {
    requestAnimationFrame(() => flatListRef.current?.scrollToEnd({ animated: true }));
  }, [messages.length]);

  const handleSend = async () => {
    const text = inputText.trim();
    if (!text) return;
    setInputText('');
    setInputHeight(40);
    const optimistic = { id: `tmp-${Date.now()}`, text, sender: 'me', createdAt: new Date().toISOString() };
    setMessages(prev => [...prev, optimistic]);

    try {
      const { at, rt } = await loadSession();
      // Need partnerId for sending; if missing, try ensure meta
      let rid = partnerId;
      if (!rid) {
        await fetchConversationMeta(at, rt);
        rid = partnerId;
      }
      if (!rid) return;
      const res = await fetch(`${API_BASE}/message/send`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}`,
        },
        body: JSON.stringify({ receiverId: rid, content: text }),
      });
      if (!res.ok) return;
      // Refresh messages to replace optimistic
      await fetchMessages(at, rt);
    } catch {}
  };

  const InputBar = (
    <View style={[styles.inputContainerWrapper, { paddingBottom: Math.max(insets.bottom, 8) }]}>
      <View style={styles.inputContainer}>
        <TouchableOpacity style={styles.mediaButton}>
          <Ionicons name="images-outline" size={20} color="#888" />
        </TouchableOpacity>

        <TextInput
          style={[styles.input, { height: Math.max(40, inputHeight) }]}
          placeholder="Write a message..."
          placeholderTextColor="#888"
          value={inputText}
          onChangeText={setInputText}
          multiline
          onContentSizeChange={(e) =>
            setInputHeight(e.nativeEvent.contentSize.height)
          }
        />

        <TouchableOpacity onPress={handleSend} style={styles.sendButton}>
          <Ionicons name="send" size={20} color="white" />
        </TouchableOpacity>
      </View>
    </View>
  );

  return (
    <SafeAreaView style={styles.container}>
      <Header title={formatTitle(partnerName)} showSearch={true} />

      {Platform.OS === 'ios' ? (
        <KeyboardAvoidingView
          style={{ flex: 1 }}
          behavior="padding"
          keyboardVerticalOffset={insets.bottom}
        >
          <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
            <View style={{ flex: 1 }}>
              <FlatList
                key={String(conversationId)}
                ref={flatListRef}
                data={messages}
                keyExtractor={(item) => item.id}
                renderItem={renderItem}
                contentContainerStyle={[styles.chatContainer, { paddingBottom: INPUT_BAR_BASE_HEIGHT + Math.max(insets.bottom, 8) + 8 }]}
                style={{ flex: 1 }}
                keyboardShouldPersistTaps="handled"
                initialNumToRender={20}
                maxToRenderPerBatch={10}
                windowSize={7}
                removeClippedSubviews={false}
                showsVerticalScrollIndicator
                decelerationRate={Platform.OS === 'ios' ? 'fast' : 0.98}
                scrollEventThrottle={16}
                ListFooterComponent={<View style={{ height: INPUT_BAR_BASE_HEIGHT + Math.max(insets.bottom, 8) }} />}
              />
              {InputBar}
            </View>
          </TouchableWithoutFeedback>
        </KeyboardAvoidingView>
      ) : (
        <TouchableWithoutFeedback onPress={Keyboard.dismiss}>
          <View style={{ flex: 1 }}>
            <FlatList
              key={String(conversationId)}
              ref={flatListRef}
              data={messages}
              keyExtractor={(item) => item.id}
              renderItem={renderItem}
              contentContainerStyle={[styles.chatContainer, { paddingBottom: INPUT_BAR_BASE_HEIGHT + Math.max(insets.bottom, 8) + 8 }]}
              style={{ flex: 1 }}
              keyboardShouldPersistTaps="handled"
              initialNumToRender={20}
              maxToRenderPerBatch={10}
              windowSize={7}
              removeClippedSubviews={false}
              showsVerticalScrollIndicator
              decelerationRate={Platform.OS === 'ios' ? 'fast' : 0.98}
              scrollEventThrottle={16}
              ListFooterComponent={<View style={{ height: INPUT_BAR_BASE_HEIGHT + Math.max(insets.bottom, 8) }} />}
            />
            <Animated.View style={{ position: 'absolute', left: 0, right: 0, bottom: keyboardHeight }}>
              {InputBar}
            </Animated.View>
          </View>
        </TouchableWithoutFeedback>
      )}
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  chatContainer: { padding: 10 },
  messageRow: { flexDirection: 'row', marginBottom: 8, alignItems: 'flex-end' },
  leftAlign: { justifyContent: 'flex-start' },
  rightAlign: { justifyContent: 'flex-end' },
  avatar: { width: 35, height: 35, borderRadius: 17.5, marginRight: 8 },
  bubble: {
    maxWidth: '75%',
    paddingVertical: 10,
    paddingHorizontal: 15,
    borderRadius: 20,
    elevation: 1,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  otherBubble: { backgroundColor: '#fff' },
  myBubble: { backgroundColor: '#6200EE' },
  messageText: { fontSize: 15, color: '#000' },
  myMessageText: { color: '#fff' },
  timestamp: { fontSize: 10, color: '#888', marginTop: 4, alignSelf: 'flex-start' },
  myTimestamp: { fontSize: 10, color: '#e6dbff', marginTop: 4, alignSelf: 'flex-end' },
  inputContainerWrapper: { backgroundColor: '#fff' },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 15,
    paddingVertical: 6,
    borderTopWidth: StyleSheet.hairlineWidth,
    borderTopColor: '#e0e0e0',
    backgroundColor: '#fff',
  },
  input: {
    flex: 1,
    paddingVertical: 6,
    paddingHorizontal: 15,
    fontSize: 16,
    borderRadius: 25,
    backgroundColor: '#f0f0f0',
    marginHorizontal: 8,
    maxHeight: 120,
  },
  sendButton: {
    backgroundColor: '#6200EE',
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
  },
  mediaButton: { padding: 5 },
});

export default ViewMessageScreen;
