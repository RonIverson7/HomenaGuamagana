import React, { useEffect, useState, useCallback } from 'react';
import { StyleSheet, View, Text, SafeAreaView, Image, TouchableOpacity, ScrollView } from 'react-native';
import { useRouter, useFocusEffect } from 'expo-router';
import Header from '../components/Header'; // Reusable header
import { supabase } from "../../supabase/supabaseClient";
import io from 'socket.io-client';

// Chat item component
const ChatItem = ({ name, lastMessage, imageSource, onPress }) => {
  const resolvedSource = typeof imageSource === 'string' ? { uri: imageSource } : imageSource;
  return (
    <TouchableOpacity style={styles.chatItem} onPress={onPress}>
      {resolvedSource ? (
        <Image source={resolvedSource} style={styles.chatImage} />
      ) : (
        <View style={[styles.chatImage, styles.placeholderCircle]} />
      )}
      <View style={styles.chatTextContainer}>
        <Text style={styles.chatName}>{name}</Text>
        <Text style={styles.chatLastMessage} numberOfLines={1}>{lastMessage}</Text>
      </View>
    </TouchableOpacity>
  );
};

const MessagesScreen = () => {
  const router = useRouter();
  const API_BASE = "http://192.168.100.83:3000/api";
  const API_ORIGIN = API_BASE.replace(/\/api$/, "");

  const [conversations, setConversations] = useState([]);
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const [loading, setLoading] = useState(true);

  const resolveUrl = (u) => {
    if (!u) return null;
    return u.startsWith('http') ? u : `${API_ORIGIN}${u}`;
  };

  const fetchConversations = useCallback(async () => {
    try {
      const { data } = await supabase.auth.getSession();
      const at = data?.session?.access_token || null;
      const rt = data?.session?.refresh_token || null;
      setAccessToken(at);
      setRefreshToken(rt);

      setLoading(true);
      const res = await fetch(`${API_BASE}/message/getConversation`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}`,
        },
      });
      if (!res.ok) {
        console.warn('[messages.js] Failed to fetch conversations:', res.status, res.statusText);
        setConversations([]);
        return;
      }
      const json = await res.json();
      const list = Array.isArray(json?.conversations) ? json.conversations : [];
      const mapped = list.map((c) => {
        const other = c.otherUser || {};
        const nameParts = [other.firstName, other.middleName, other.lastName].filter(Boolean);
        const displayName = (nameParts.join(' ') || other.username || 'User').trim();
        return {
          id: c.conversationId,
          name: displayName,
          lastMessage: c.lastMessageContent || '',
          avatar: resolveUrl(other.profilePicture),
          lastMessageTime: c.lastMessageTimestamp || c.lastMessageTime || c.updatedAt || 0,
        };
      });
      // Sort by most recent message first
      const sorted = mapped.sort((a, b) => {
        const timeA = new Date(a.lastMessageTime).getTime() || 0;
        const timeB = new Date(b.lastMessageTime).getTime() || 0;
        return timeB - timeA;
      });
      setConversations(sorted);
    } catch (e) {
      console.warn('[messages.js] Error fetching conversations:', e?.message || e);
      setConversations([]);
    } finally {
      setLoading(false);
    }
  }, [API_BASE]);

  useEffect(() => {
    fetchConversations();
  }, [fetchConversations]);

  // Refresh conversation list when screen comes into focus (e.g., after sending a message)
  useFocusEffect(
    useCallback(() => {
      fetchConversations();
    }, [fetchConversations])
  );

  // Realtime updates for conversation list
  useEffect(() => {
    let socket;
    let mounted = true;
    const setup = async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const uid = data?.session?.user?.id;
        if (!uid) return;
        socket = io(API_ORIGIN, { transports: ['websocket'], withCredentials: true });
        socket.on('connect', () => {
          socket.emit('join', uid);
        });
        const refresh = () => { if (mounted) fetchConversations(); };
        socket.on('message:new', refresh);
        socket.on('conversation:updated', refresh);
      } catch {}
    };
    setup();
    return () => {
      mounted = false;
      try { if (socket) { socket.removeAllListeners(); socket.disconnect(); } } catch {}
    };
  }, [API_ORIGIN, fetchConversations]);

  return (
    <SafeAreaView style={styles.container}>
      <Header title="Messages" showSearch={true} />

      <ScrollView style={styles.chatList}>
        {loading && conversations.length === 0 ? (
          <Text style={{ margin: 12 }}>Loading...</Text>
        ) : null}
        {conversations.map((item) => (
          <ChatItem
            key={item.id}
            name={item.name}
            lastMessage={item.lastMessage}
            imageSource={item.avatar}
            onPress={() => router.push({ pathname: '/(drawer)/viewMessage', params: { conversationId: String(item.id || ''), name: item.name } })}
          />
        ))}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  chatList: { flex: 1, paddingHorizontal: 15 },
  chatItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  chatImage: { width: 50, height: 50, borderRadius: 25, marginRight: 15 },
  chatTextContainer: { flex: 1 },
  chatName: { fontSize: 16, fontWeight: 'bold' },
  chatLastMessage: { fontSize: 14, color: '#888' },
  placeholderCircle: { backgroundColor: '#e9e9e9', borderWidth: 1, borderColor: '#ddd' },
});

export default MessagesScreen;
