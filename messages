import React, { useEffect, useState, useCallback } from 'react';
import { StyleSheet, View, Text, SafeAreaView, Image, TouchableOpacity, ScrollView } from 'react-native';
import { useRouter, useFocusEffect } from 'expo-router';
import Header from '../components/Header'; // Reusable header
import { supabase } from "../../supabase/supabaseClient";
import io from 'socket.io-client';

// Chat item component
const ChatItem = ({ name, lastMessage, imageSource, lastMessageTime, onPress }) => {
  const resolvedSource = typeof imageSource === 'string' ? { uri: imageSource } : imageSource;
  return (
    <TouchableOpacity style={styles.chatItem} onPress={onPress}>
      {resolvedSource ? (
        <Image source={resolvedSource} style={styles.chatImage} />
      ) : (
        <View style={[styles.chatImage, styles.placeholderCircle]} />
      )}
      <View style={styles.chatTextContainer}>
        <View style={styles.chatHeaderRow}>
          <Text style={styles.chatName}>{name}</Text>
          <Text style={styles.chatTime}>{lastMessageTime}</Text>
        </View>
        <Text style={styles.chatLastMessage} numberOfLines={1}>{lastMessage}</Text>
      </View>
    </TouchableOpacity>
  );
};

const MessagesScreen = () => {
  const router = useRouter();
  const API_BASE = "http://192.168.100.83:3000/api";
  const API_ORIGIN = API_BASE.replace(/\/api$/, "");

  const [conversations, setConversations] = useState([]);
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const [loading, setLoading] = useState(true);

  const resolveUrl = (u) => {
    if (!u) return null;
    return u.startsWith('http') ? u : `${API_ORIGIN}${u}`;
  };

  const normalizeTimestamp = (t) => {
    if (!t) return null;
    if (t instanceof Date) return t.getTime();
    if (typeof t === 'number') {
      return t < 1e12 ? t * 1000 : t;
    }
    if (typeof t === 'string') {
      const num = Number(t);
      if (!Number.isNaN(num) && t.trim().match(/^\d+$/)) {
        return num < 1e12 ? num * 1000 : num;
      }
      const d = new Date(t);
      const ms = d.getTime();
      return Number.isNaN(ms) ? null : ms;
    }
    return null;
  };

  const formatMessageTime = (t) => {
    if (!t) return '';
    const d = new Date(t);
    if (isNaN(d.getTime())) return '';
    const now = new Date();
    const isSameDay = d.toDateString() === now.toDateString();
    if (isSameDay) {
      let hours = d.getHours();
      const minutes = d.getMinutes().toString().padStart(2, '0');
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12 || 12;
      return `${hours}:${minutes} ${ampm}`;
    }
    const diffMs = now.setHours(0,0,0,0) - new Date(d.toDateString()).setHours(0,0,0,0);
    const diffDays = Math.round(diffMs / (1000 * 60 * 60 * 24));
    if (diffDays < 7) {
      return d.toLocaleDateString(undefined, { weekday: 'short' });
    }
    return d.toLocaleDateString();
  };

  const fetchConversations = useCallback(async () => {
    try {
      const { data } = await supabase.auth.getSession();
      const at = data?.session?.access_token || null;
      const rt = data?.session?.refresh_token || null;
      setAccessToken(at);
      setRefreshToken(rt);

      setLoading(true);
      const res = await fetch(`${API_BASE}/message/getConversation`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}`,
        },
      });
      if (!res.ok) {
        console.warn('[messages.js] Failed to fetch conversations:', res.status, res.statusText);
        setConversations([]);
        return;
      }
      const json = await res.json();
      const list = Array.isArray(json?.conversations) ? json.conversations : [];
      const mapped = list.map((c) => {
        const other = c.otherUser || {};
        const nameParts = [other.firstName, other.middleName, other.lastName].filter(Boolean);
        const displayName = (nameParts.join(' ') || other.username || 'User').trim();
        const tsRaw = (
          (c.lastMessageTimestamp) ||
          (c.lastMessageTime) ||
          (c.lastMessage && (c.lastMessage.createdAt || c.lastMessage.created_at)) ||
          c.updatedAt || c.updated_at || null
        );
        const ts = normalizeTimestamp(tsRaw);
        return {
          id: c.conversationId,
          name: displayName,
          lastMessage: (c.lastMessage && (c.lastMessage.content || c.lastMessage.text)) || c.lastMessageContent || '',
          avatar: resolveUrl(other.profilePicture),
          lastMessageTime: ts,
        };
      });
      // Sort by most recent message first
      const sorted = mapped.sort((a, b) => {
        const timeA = typeof a.lastMessageTime === 'number' ? a.lastMessageTime : normalizeTimestamp(a.lastMessageTime) || 0;
        const timeB = typeof b.lastMessageTime === 'number' ? b.lastMessageTime : normalizeTimestamp(b.lastMessageTime) || 0;
        return timeB - timeA;
      });
      setConversations(sorted);

      // Fallback enrichment: fetch latest message for items missing timestamp
      const missing = sorted.filter(it => !it.lastMessageTime && it.id);
      if (missing.length > 0) {
        try {
          const enriched = await Promise.all(missing.map(async (it) => {
            try {
              const r = await fetch(`${API_BASE}/message/getConversation/${encodeURIComponent(String(it.id))}` , {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json',
                  'Cookie': `access_token=${at || ''}; refresh_token=${rt || ''}`,
                },
              });
              if (!r.ok) return it;
              const j = await r.json();
              const rows = Array.isArray(j?.messages) ? j.messages : [];
              const last = rows[rows.length - 1];
              if (!last) return it;
              const ts2 = normalizeTimestamp(last.createdAt || last.created_at);
              return {
                ...it,
                lastMessage: (last.content || last.text || it.lastMessage || ''),
                lastMessageTime: ts2 || it.lastMessageTime,
              };
            } catch {
              return it;
            }
          }));
          const merged = sorted.map(s => enriched.find(e => e.id === s.id) || s)
            .sort((a, b) => {
              const timeA = typeof a.lastMessageTime === 'number' ? a.lastMessageTime : normalizeTimestamp(a.lastMessageTime) || 0;
              const timeB = typeof b.lastMessageTime === 'number' ? b.lastMessageTime : normalizeTimestamp(b.lastMessageTime) || 0;
              return timeB - timeA;
            });
          setConversations(merged);
        } catch {}
      }
    } catch (e) {
      console.warn('[messages.js] Error fetching conversations:', e?.message || e);
      setConversations([]);
    } finally {
      setLoading(false);
    }
  }, [API_BASE]);

  useEffect(() => {
    fetchConversations();
  }, [fetchConversations]);

  // Refresh conversation list when screen comes into focus (e.g., after sending a message)
  useFocusEffect(
    useCallback(() => {
      fetchConversations();
    }, [fetchConversations])
  );

  // Realtime updates for conversation list
  useEffect(() => {
    let socket;
    let mounted = true;
    const setup = async () => {
      try {
        const { data } = await supabase.auth.getSession();
        const uid = data?.session?.user?.id;
        if (!uid) return;
        socket = io(API_ORIGIN, { transports: ['websocket'], withCredentials: true });
        socket.on('connect', () => {
          socket.emit('join', uid);
        });
        const refresh = () => { if (mounted) fetchConversations(); };
        socket.on('message:new', refresh);
        socket.on('conversation:updated', refresh);
      } catch {}
    };
    setup();
    return () => {
      mounted = false;
      try { if (socket) { socket.removeAllListeners(); socket.disconnect(); } } catch {}
    };
  }, [API_ORIGIN, fetchConversations]);

  return (
    <SafeAreaView style={styles.container}>
      <Header title="Messages" showSearch={true} />

      <ScrollView style={styles.chatList}>
        {loading && conversations.length === 0 ? (
          <Text style={{ margin: 12 }}>Loading...</Text>
        ) : null}
        {conversations.map((item) => (
          <ChatItem
            key={item.id}
            name={item.name}
            lastMessage={item.lastMessage}
            imageSource={item.avatar}
            lastMessageTime={formatMessageTime(item.lastMessageTime)}
            onPress={() => router.push({ pathname: '/(drawer)/viewMessage', params: { conversationId: String(item.id || ''), name: item.name } })}
          />
        ))}
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  chatList: { flex: 1, paddingHorizontal: 15 },
  chatItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  chatImage: { width: 50, height: 50, borderRadius: 25, marginRight: 15 },
  chatTextContainer: { flex: 1 },
  chatHeaderRow: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'baseline' },
  chatName: { fontSize: 16, fontWeight: 'bold' },
  chatTime: { fontSize: 12, color: '#888' },
  chatLastMessage: { fontSize: 14, color: '#888' },
  placeholderCircle: { backgroundColor: '#e9e9e9', borderWidth: 1, borderColor: '#ddd' },
});

export default MessagesScreen;
