import React, { useState, useEffect } from 'react';
import { StyleSheet, View, Text, SafeAreaView, Image, TouchableOpacity, Modal, TextInput, TouchableWithoutFeedback, FlatList, ScrollView, Platform, KeyboardAvoidingView, Keyboard, Dimensions, BackHandler, RefreshControl, Alert } from 'react-native';
import { Feather, Ionicons } from '@expo/vector-icons';
import * as ImagePicker from 'expo-image-picker';
import DateTimePicker from '@react-native-community/datetimepicker';
import Header from '../components/Header';
import { supabase } from "../../supabase/supabaseClient";
import { useRouter, useFocusEffect } from "expo-router";
import AndroidFooterSpacer from '../components/Footer';

const { width: SCREEN_WIDTH } = Dimensions.get('window');

const HomeScreen = () => {
  const [selectedImage, setSelectedImage] = useState(null);
  const [selectedImages, setSelectedImages] = useState([]); // Array of images for carousel
  const [currentImageIndex, setCurrentImageIndex] = useState(0); // Current image index
  const [modalVisible, setModalVisible] = useState(false);
  const [postText, setPostText] = useState('');
  const [pickedImages, setPickedImages] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [posts, setPosts] = useState([]);
  const [events, setEvents] = useState([]);
  const [likes, setLikes] = useState({});
  const [comments, setComments] = useState({});
  const [userLikes, setUserLikes] = useState({});
  const [accessToken, setAccessToken] = useState(null);
  const [refreshToken, setRefreshToken] = useState(null);
  const [role, setRole] = useState(null);
  const [searchQuery, setSearchQuery] = useState('');
  const [refreshing, setRefreshing] = useState(false);
  const [currentUserId, setCurrentUserId] = useState(null);
  const [menuPost, setMenuPost] = useState(null);
  // Pagination state (mirror web)
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const POSTS_PER_PAGE = 10;
  const [editModalVisible, setEditModalVisible] = useState(false);
  const [editingPost, setEditingPost] = useState(null);
  const [editText, setEditText] = useState("");
  const [editSaving, setEditSaving] = useState(false);
  const [editImages, setEditImages] = useState([]);
  const [originalEditImages, setOriginalEditImages] = useState([]);
  
  // Art interests modal
  const [interestsModalVisible, setInterestsModalVisible] = useState(false);
  const [selectedInterests, setSelectedInterests] = useState([]);
  const [hasArtPreferences, setHasArtPreferences] = useState(false);


  const [commentModalVisible, setCommentModalVisible] = useState(false);
  const [currentPostComments, setCurrentPostComments] = useState([]);
  const [currentPostId, setCurrentPostId] = useState(null);
  const [newCommentText, setNewCommentText] = useState('');


  // Profile modal and fields
  const [profileModalVisible, setProfileModalVisible] = useState(false);


  const [firstName, setFirstName] = useState("");
  const [middleName, setMiddleName] = useState("");
  const [lastName, setLastName] = useState("");
  const [userNameField, setUserNameField] = useState("");
  const [username, setUsername] = useState("");
  const [sex, setSex] = useState("");
  const [birthday, setBirthday] = useState(new Date());
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [showSexDropdown, setShowSexDropdown] = useState(false);
  const [address, setAddress] = useState("");
  const [bio, setBio] = useState("");
  const [about, setAbout] = useState("");
  const [image, setImage] = useState(null);
  const [backgroundImage, setBackgroundImage] = useState(null);


  // Temporary unsaved edits
  const [tempImage, setTempImage] = useState(null);
  const [tempBackgroundImage, setTempBackgroundImage] = useState(null);


  const formattedDate = birthday.toLocaleDateString("en-US");


  const router = useRouter();
  const API_BASE = "http://192.168.100.83:3000/api";



  // Helper: coerce various shapes into a valid uri string
  const ensureUri = (value) => {
    if (!value) return null;
    if (typeof value === 'string') return value || null;
    if (Array.isArray(value)) {
      const first = value.find((v) => typeof v === 'string' && v);
      return first || null;
    }
    if (typeof value === 'object' && value.uri) {
      return typeof value.uri === 'string' ? value.uri : null;
    }
    return null;
  };

  const pickEditImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      quality: 1,
      allowsMultipleSelection: true,
    });
    if (!result.canceled) {
      const uris = result.assets.map(a => a.uri);
      setEditImages(prev => {
        const merged = [...prev, ...uris];
        return merged.slice(0, 4); // cap to 4 to match create UI
      });
    }
  };

  const removeEditImage = (index) => {
    setEditImages(prev => prev.filter((_, i) => i !== index));
  };


  const saveEditPost = async () => {
    if (!editingPost) return;
    const postId = editingPost.id;
    try {
      setEditSaving(true);

      // Build FormData to mirror web EditPostModal
      const fd = new FormData();
      fd.append('description', String(editText ?? ''));

      // Determine existing vs new images
      const isHttpUrl = (u) => typeof u === 'string' && /^https?:\/\//i.test(u);
      const origSet = new Set(originalEditImages);
      const currentSet = new Set(editImages);

      // existingImages: keep URLs that remained
      (editImages || []).forEach((u) => {
        if (isHttpUrl(u) && origSet.has(u)) {
          fd.append('existingImages', u);
        }
      });

      // imagesToRemove: urls present originally but not in current selection
      (originalEditImages || []).forEach((u) => {
        if (!currentSet.has(u)) {
          fd.append('imagesToRemove', u);
        }
      });

      // images: new local images (URIs)
      (editImages || []).forEach((uri, index) => {
        if (!isHttpUrl(uri)) {
          const filename = (String(uri).split('/').pop()) || `image_${index}.jpg`;
          const match = /\.(\w+)$/.exec(filename);
          const type = match ? `image/${match[1]}` : 'image/jpeg';
          fd.append('images', { uri: String(uri), name: filename, type });
        }
      });

      const res = await fetch(`${API_BASE}/homepage/posts/${postId}`, {
        method: 'PUT',
        headers: {
          'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}`,
        },
        body: fd,
      });
      if (!res.ok) {
        let msg = 'Failed to update post';
        try { const j = await res.json(); if (j?.error || j?.message) msg = String(j.error || j.message); } catch {}
        throw new Error(msg);
      }

      // Refresh posts to reflect new remote image URLs
      await fetchPosts();
      setEditModalVisible(false);
      setEditingPost(null);
      setEditText('');
      setEditImages([]);
      setOriginalEditImages([]);
    } catch (e) {
      Alert.alert('Error', e?.message || 'Failed to update post');
    } finally {
      setEditSaving(false);
    }
  };

  
  // Check if user has art preferences
  const checkArtPreferences = async (at, rt) => {
    try {
      const res = await fetch(`${API_BASE}/gallery/getArtPreference`, {
        method: "GET",
        headers: {
          'Cookie': `access_token=${at}; refresh_token=${rt}`,
        },
      });
      const data = await res.json();
      
      if (data?.artPreference) {
        // Check if user has selected at least one preference
        const prefs = data.artPreference;
        const hasPreferences = Object.keys(prefs).some(key => 
          key !== 'userId' && key !== 'id' && key !== 'created_at' && prefs[key] === true
        );
        setHasArtPreferences(hasPreferences);
        return hasPreferences;
      }
      return false;
    } catch (err) {
      console.log("checkArtPreferences error:", err?.message || err);
      return false;
    }
  };

  // Fetch user profile from backend to determine if profile modal should show
  const fetchUserProfile = async (at, rt) => {
    try {
      const res = await fetch(`${API_BASE}/profile/getProfile`, {
        method: "GET",
        headers: {
          'Cookie': `access_token=${at}; refresh_token=${rt}`,
        },
      });
      const data = await res.json();


      if (data?.profile) {
        const p = data.profile;
        setFirstName(p.firstName || "");
        setMiddleName(p.middleName || "");
        setLastName(p.lastName || "");
        setUserNameField(p.username || "");
        setUsername(p.username || "");
        // accept both 'sex' and 'gender' from backend
        setSex(p.sex || p.gender || "");
        setAddress(p.address || "");
        setBio(p.bio || "");
        setAbout(p.about || "");
        // accept both 'birthday' and 'birthdate'
        if (p.birthday || p.birthdate) setBirthday(new Date(p.birthday || p.birthdate));
        // Align with profile.js which resolves URLs and may use profilePicture/coverPicture
        const avatarUrl = p.profilePicture || p.avatar;
        const coverUrl = p.coverPicture || p.cover;
        if (avatarUrl) setImage({ uri: avatarUrl });
        if (coverUrl) setBackgroundImage({ uri: coverUrl });


        // Only show modal if profile is incomplete (you can tweak the fields checked)
        if (!p.username || !p.firstName || !p.lastName) {
          setProfileModalVisible(true);
        } else {
          setProfileModalVisible(false);
          // Check art preferences after profile is complete
          const hasPrefs = await checkArtPreferences(at, rt);
          if (!hasPrefs) {
            // Show interests modal if no preferences set
            setInterestsModalVisible(true);
          }
        }
      } else {
        // No profile data found - require completion
        setProfileModalVisible(true);
      }
    } catch (err) {
      console.log("fetchUserProfile error:", err?.message || err);
      // If error occurs, be conservative and show the modal so user can complete profile
      setProfileModalVisible(true);
    }
  };

  // Fetch user role (concept applied): include credentials and log raw/resolved role
  const fetchRole = async (at, rt) => {
    try {
      const res = await fetch(`${API_BASE}/users/role`, {
        method: "GET",
        credentials: "include",
        headers: {
          // RN fetch doesn't always handle cookies automatically; include Cookie header
          'Cookie': `access_token=${at}; refresh_token=${rt}`,
        },
      });
      if (!res.ok) throw new Error(`Failed to fetch role: ${res.status} ${res.statusText}`);

      // Read as text first for reliable logging, then try JSON
      const bodyText = await res.text();
      console.log("[home.js] Fetched role raw:", bodyText);
      let data = null;
      try {
        data = bodyText ? JSON.parse(bodyText) : null;
      } catch (_) {
        data = bodyText; // sometimes API returns a plain string role
      }

      const resolvedRole = typeof data === 'string'
        ? data
        : (data?.role || data?.user?.role || data?.data?.role || data?.profile?.role || null);

      setRole(resolvedRole);
      console.log("[home.js] Resolved role:", resolvedRole ?? "(null/unknown)");
    } catch (error) {
      console.error("[home.js] Error fetching role:", error?.message || error);
      setRole(null);
    }
  };


  useEffect(() => {
    const init = async () => {
      try {
        setLoading(true);
        const { data } = await supabase.auth.getSession();
        const at = data?.session?.access_token || null;
        const rt = data?.session?.refresh_token || null;
        setAccessToken(at);
        setRefreshToken(rt);


        if (at && rt) {
          // Get role and profile when authenticated
          await fetchRole(at, rt);
          await fetchUserProfile(at, rt);
          await fetchPostsPage(1, false, at, rt);
          await fetchEvents(at, rt);
        } else {
          // no session tokens - still fetch posts (may be public) or skip
          await fetchPostsPage(1, false, at, rt);
          await fetchEvents(at, rt);
        }
      } catch (e) {
        setError(e.message || "Failed to initialize session");
      } finally {
        setLoading(false);
      }
    };
    init();
  }, []);

  // Android hardware back: close any open modal in priority order, else pass through
  useFocusEffect(
    React.useCallback(() => {
      const onBackPress = () => {
        if (selectedImage !== null && selectedImages.length > 0) {
          setSelectedImage(null);
          setSelectedImages([]);
          setCurrentImageIndex(0);
          return true;
        }
        if (commentModalVisible) {
          setCommentModalVisible(false);
          return true;
        }
        if (modalVisible) {
          setModalVisible(false);
          return true;
        }
        if (profileModalVisible) {
          setProfileModalVisible(false);
          return true;
        }
        if (interestsModalVisible) {
          setInterestsModalVisible(false);
          return true;
        }
        return false; // allow default behavior
      };
      const sub = BackHandler.addEventListener('hardwareBackPress', onBackPress);
      return () => sub.remove();
    }, [selectedImage, selectedImages.length, commentModalVisible, modalVisible, profileModalVisible, interestsModalVisible])
  );


  // Paginated fetch like web: when append=false (page 1) include announcements; when append=true append only posts
  const fetchPostsPage = async (p = 1, append = false, at = accessToken, rt = refreshToken) => {
    try {
      setLoading(true);
      const session = await supabase.auth.getSession();
      const currentUid = session?.data?.session?.user?.id;
      if (currentUid && !currentUserId) setCurrentUserId(currentUid);


      const res = await fetch(`${API_BASE}/homepage/getPost?page=${p}&limit=${POSTS_PER_PAGE}`, {
        method: 'GET',
        headers: {
          'Cookie': `access_token=${at}; refresh_token=${rt}`,
        },
      });
      const data = await res.json();

      const incomingAnnouncements = Array.isArray(data.announcements) ? data.announcements : [];
      const incomingPosts = Array.isArray(data.posts) ? data.posts : [];

      if (append) {
        // Append new posts avoiding duplicates by id
        setPosts(prev => {
          const existingIds = new Set(prev.map(x => x.id));
          const toAdd = incomingPosts.filter(x => !existingIds.has(x.id));
          return [...prev, ...toAdd];
        });
      } else {
        // First page: include announcements + posts sorted like before via filteredData function
        setPosts([...(incomingAnnouncements || []), ...(incomingPosts || [])]);
      }


      const reactCounts = {};
      data.reacts?.forEach(r => {
        reactCounts[r.postId] = (reactCounts[r.postId] || 0) + 1;
      });
      setLikes(prev => append ? { ...prev, ...reactCounts } : reactCounts);


      const commentCounts = {};
      data.comments?.forEach(c => {
        commentCounts[c.postId] = (commentCounts[c.postId] || 0) + 1;
      });
      setComments(prev => append ? { ...prev, ...commentCounts } : commentCounts);


      const initialLikes = {};
      data.reacts?.forEach(r => {
        if (r.userId === currentUid) {
          initialLikes[r.postId] = true;
        }
      });
      setUserLikes(prev => append ? { ...prev, ...initialLikes } : initialLikes);

      // hasMore based on API or length check
      if (data.pagination && typeof data.pagination.hasMore === 'boolean') {
        setHasMore(data.pagination.hasMore);
      } else {
        setHasMore(incomingPosts.length === POSTS_PER_PAGE);
      }


    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // Backward-compat wrapper where older calls used fetchPosts()
  const fetchPosts = async (at = accessToken, rt = refreshToken) => {
    setPage(1);
    await fetchPostsPage(1, false, at, rt);
  };

  const loadMore = async () => {
    if (!hasMore || isLoadingMore) return;
    setIsLoadingMore(true);
    const next = page + 1;
    try {
      await fetchPostsPage(next, true);
      setPage(next);
    } finally {
      setIsLoadingMore(false);
    }
  };

  const fetchEvents = async (at = accessToken, rt = refreshToken) => {
    try {
      const res = await fetch(`${API_BASE}/event/getEvents`, {
        method: 'GET',
        headers: {
          'Cookie': `access_token=${at}; refresh_token=${rt}`,
        },
      });
      const data = await res.json();
      const eventList = Array.isArray(data?.data) ? data.data : [];
      setEvents(eventList);
    } catch (err) {
      console.error('Error fetching events:', err.message);
      setEvents([]);
    }
  };


  const pickImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      quality: 1,
      allowsMultipleSelection: true,
    });
    if (!result.canceled) {
      const uris = result.assets.map(asset => asset.uri);
      setPickedImages(prev => [...prev, ...uris]);
    }
  };


  const uploadPost = async () => {
    if (!postText && pickedImages.length === 0) return;


    const formData = new FormData();
    formData.append("description", String(postText ?? ""));
    formData.append("text", String(postText ?? ""));
    
    // Backend expects: file, file2, file3, file4 (max 4 images)
    pickedImages.slice(0, 4).forEach((uri, index) => {
      const filename = uri.split("/").pop();
      const match = /\.(\w+)$/.exec(filename);
      const type = match ? `image/${match[1]}` : `image/jpeg`;
      
      // Field names: file, file2, file3, file4
      const fieldName = index === 0 ? "file" : `file${index + 1}`;
      formData.append(fieldName, { uri, name: filename, type });
    });


    try {
      setLoading(true);
      const res = await fetch(`${API_BASE}/homepage/createPost`, {
        method: "POST",
        headers: {
          'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}`,
        },
        body: formData,
      });
      if (!res.ok) {
        let errMsg = `Failed to upload post (${res.status})`;
        try {
          const txt = await res.text();
          try {
            const j = txt ? JSON.parse(txt) : null;
            if (j && (j.message || j.error)) errMsg = String(j.message || j.error);
            else if (txt) errMsg = txt;
          } catch {
            if (txt) errMsg = txt;
          }
        } catch {}
        throw new Error(errMsg);
      }
      let data = null;
      try { data = await res.json(); } catch {}
      setModalVisible(false);
      setPostText("");
      setPickedImages([]);
      fetchPosts();
    } catch (err) {
      setError(err?.message || "Failed to upload post");
    } finally {
      setLoading(false);
    }
  };


  const handleLike = async (postId) => {
    const alreadyLiked = userLikes[postId] || false;


    setUserLikes(prev => ({
      ...prev,
      [postId]: !alreadyLiked,
    }));


    try {
      const res = await fetch(`${API_BASE}/homepage/createReact`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}`,
        },
        body: JSON.stringify({ postId }),
      });


      if (!res.ok) throw new Error(`Failed to react (${res.status})`);
      await fetchPosts();
    } catch (e) {
      console.error(e.message);
      setUserLikes(prev => ({
        ...prev,
        [postId]: alreadyLiked,
      }));
    }
  };


  const openCommentsModal = async (postId) => {
    try {
      setLoading(true);
      const res = await fetch(`${API_BASE}/homepage/getComments?postId=${postId}`, {
        method: 'GET',
        headers: { 'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}` },
      });
      const data = await res.json();
      setCurrentPostComments(data.comments || []);
      setCurrentPostId(postId);
      setCommentModalVisible(true);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };


  const postComment = async () => {
    if (!newCommentText.trim()) return;


    try {
      await fetch(`${API_BASE}/homepage/createComment`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}`,
        },
        body: JSON.stringify({
          postId: currentPostId,
          text: newCommentText,
        }),
      });
      setNewCommentText('');
      openCommentsModal(currentPostId); // refresh comments
      fetchPosts();
    } catch (err) {
      console.error(err);
    }
  };


  const removeImage = (index) => {
    setPickedImages(prev => prev.filter((_, i) => i !== index));
  };


  const pickProfileImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [1, 1],
      quality: 1,
    });


    if (!result.canceled) {
      setTempImage({ uri: result.assets[0].uri });
    }
  };


  const pickBackgroundImage = async () => {
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [16, 9],
      quality: 1,
    });


    if (!result.canceled) {
      setTempBackgroundImage({ uri: result.assets[0].uri });
    }
  };


  const saveProfileToDB = async () => {
    try {
      const formData = new FormData();


      if (tempImage) {
        const filename = tempImage.uri.split("/").pop();
        const match = /\.(\w+)$/.exec(filename);
        const type = match ? `image/${match[1]}` : `image`;
        formData.append("avatar", {
          uri: tempImage.uri,
          name: filename,
          type,
        });
      }


      if (tempBackgroundImage) {
        const filename = tempBackgroundImage.uri.split("/").pop();
        const match = /\.(\w+)$/.exec(filename);
        const type = match ? `image/${match[1]}` : `image`;
        formData.append("cover", {
          uri: tempBackgroundImage.uri,
          name: filename,
          type,
        });
      }

      const birthdayStr = birthday ? new Date(birthday).toISOString() : "";
      formData.append("firstName", String(firstName ?? ""));
      formData.append("middleName", String(middleName ?? ""));
      formData.append("lastName", String(lastName ?? ""));
      formData.append("username", String(userNameField || username || ""));
      formData.append("sex", String(sex ?? ""));
      // also send under alternate keys for compatibility
      formData.append("gender", String(sex ?? ""));
      formData.append("birthday", birthdayStr);
      formData.append("birthdate", birthdayStr);
      formData.append("address", String(address ?? ""));
      formData.append("bio", String(bio ?? ""));
      formData.append("about", String(about ?? ""));


      try {
        console.log("[home.js] updateProfile payload:", {
          firstName,
          middleName,
          lastName,
          username: userNameField || username,
          sex,
          gender: sex,
          birthday: birthdayStr,
          birthdate: birthdayStr,
          address,
          bio,
          about,
          hasAvatar: !!tempImage,
          hasCover: !!tempBackgroundImage,
        });
      } catch {}

      const res = await fetch(`${API_BASE}/profile/updateProfile`, {
        method: "POST",
        headers: {
          'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}`,
        },
        body: formData,
      });

      if (!res.ok) {
        let msg = "Failed to save profile";
        try {
          const errJson = await res.json();
          if (errJson?.message) msg = `${msg}: ${errJson.message}`;
        } catch {}
        throw new Error(msg);
      }


      alert("Profile saved successfully ");
      return true;
    } catch (err) {
      console.error(err);
      alert(`Failed to save profile: ${err?.message || "Unknown error"}`);
      return false;
    }
  };


  const handleProfileSave = async () => {
    const displayName =
      userNameField || [firstName, middleName, lastName].filter(Boolean).join(" ");
    setUsername(displayName);


    setImage(tempImage);
    setBackgroundImage(tempBackgroundImage);


    // Save to DB, then refresh profile from server to ensure completeness flag is accurate
    const saved = await saveProfileToDB();


    if (saved) {
      // refresh local profile state based on backend response
      await fetchUserProfile(accessToken, refreshToken);
      // if profile is complete fetchUserProfile will setProfileModalVisible(false)
      // but ensure it's closed here as well for immediate UX
      setProfileModalVisible(false);
    }
  };


  const onChangeDate = (event, selectedDate) => {
    if (selectedDate) {
      setBirthday(selectedDate);
    }
    if (Platform.OS === "android") {
      setShowDatePicker(false);
    }
  };


  const renderPost = ({ item: post }) => (
    <View key={post.id} style={styles.card}>
      <View style={styles.userInfo}>
        {(() => {
          const avatarUri = ensureUri(post.user?.avatar);
          return avatarUri ? (
            <Image source={{ uri: avatarUri }} style={styles.avatar} />
          ) : (
            <View style={[styles.avatar, styles.placeholderCircle]} />
          );
        })()}
        <Text style={styles.username}>{post.user?.name}</Text>
        <TouchableOpacity
          onPress={() => setMenuPost(post)}
          style={styles.moreBtn}
          hitSlop={{ top: 8, bottom: 8, left: 8, right: 8 }}
        >
          <Ionicons name="ellipsis-horizontal" size={20} color="#555" />
        </TouchableOpacity>
      </View>


      {!!post.text && <Text style={styles.description}>{post.text}</Text>}


      {(() => {
        // Handle both single image and array of images
        let imageArray = [];
        if (Array.isArray(post.image)) {
          imageArray = post.image;
        } else if (post.image) {
          imageArray = [post.image];
        } else if (Array.isArray(post.images)) {
          imageArray = post.images;
        } else if (post.images) {
          imageArray = [post.images];
        }
        
        const postImageUri = imageArray.length > 0 ? ensureUri(imageArray[0]) : null;
        
        return postImageUri ? (
          <TouchableOpacity onPress={() => {
            setSelectedImages(imageArray.map(img => ({ uri: ensureUri(img) })));
            setCurrentImageIndex(0);
            setSelectedImage(true); // Just a flag to open modal
          }}>
            <Image source={{ uri: postImageUri }} style={styles.postImage} resizeMode="cover" />
            {imageArray.length > 1 && (
              <View style={{
                position: 'absolute',
                top: 8,
                right: 8,
                backgroundColor: 'rgba(0,0,0,0.7)',
                paddingHorizontal: 8,
                paddingVertical: 4,
                borderRadius: 12,
              }}>
                <Text style={{ color: 'white', fontSize: 12, fontWeight: 'bold' }}>
                  1/{imageArray.length}
                </Text>
              </View>
            )}
          </TouchableOpacity>
        ) : null;
      })()}


      {!!post.timestamp && (
        <Text style={styles.timestamp}>{post.timestamp}</Text>
      )}


      <View style={styles.actions}>
        <TouchableOpacity onPress={() => handleLike(post.id)} style={{ flexDirection: 'row', alignItems: 'center' }}>
          <Ionicons
            name={userLikes[post.id] ? "heart" : "heart-outline"}
            size={20}
            color={userLikes[post.id] ? "red" : "#555"}
          />
          <Text style={styles.likeText}>{likes[post.id] || 0}</Text>
        </TouchableOpacity>


        <TouchableOpacity style={{ flexDirection: 'row', alignItems: 'center', marginLeft: 12 }} onPress={() => openCommentsModal(post.id)}>
          <Feather name="message-circle" size={20} color="#555" />
          <Text style={{ marginLeft: 4 }}>{comments[post.id] || 0}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );

  const renderEvent = ({ item: announcementPost }) => {
    // For announcement posts, look up full event data using eventId
    const fullEvent = announcementPost.eventId 
      ? events.find(e => e.eventId === announcementPost.eventId) 
      : null;
    const displayData = fullEvent || announcementPost;
    
    return (
      <TouchableOpacity 
        key={announcementPost.id} 
        style={[styles.card, styles.eventCard]}
        onPress={() => router.push({ 
          pathname: '/(drawer)/viewEvents', 
          params: { eventId: String(announcementPost.eventId || displayData.eventId || displayData.id) } 
        })}
      >
        <View style={styles.eventBadge}>
          <Ionicons name="calendar" size={14} color="#fff" />
          <Text style={styles.eventBadgeText}>Event</Text>
        </View>

        {displayData.image && (
          <Image source={{ uri: displayData.image }} style={styles.postImage} resizeMode="cover" />
        )}

        <Text style={styles.eventTitle}>{displayData.title || announcementPost.title}</Text>
        
        {!!displayData.details && (
          <Text style={styles.description} numberOfLines={3}>
            {displayData.details}
          </Text>
        )}

        {(displayData.startsAt || displayData.venueName || announcementPost.venueName) && (
          <View style={styles.eventMetaContainer}>
            {!!displayData.startsAt && (
              <View style={styles.eventMeta}>
                <Ionicons name="time-outline" size={16} color="#555" />
                <Text style={styles.eventMetaText}>
                  {new Date(displayData.startsAt).toLocaleDateString()}
                </Text>
              </View>
            )}
            {!!(displayData.venueName || announcementPost.venueName) && (
              <View style={styles.eventMeta}>
                <Ionicons name="location-outline" size={16} color="#555" />
                <Text style={styles.eventMetaText} numberOfLines={1}>
                  {displayData.venueName || announcementPost.venueName}
                </Text>
              </View>
            )}
          </View>
        )}

        <View style={styles.eventViewMore}>
          <Text style={styles.eventViewMoreText}>View Details</Text>
          <Ionicons name="chevron-forward" size={16} color="#000" />
        </View>
      </TouchableOpacity>
    );
  };


  // Updated render function for comments to include timestamp below each comment
  const renderComment = ({ item }) => (
    <View style={styles.commentBox}>
      {(() => {
        const avatarUri = ensureUri(item.user?.avatar);
        return avatarUri ? (
          <Image source={{ uri: avatarUri }} style={styles.avatar} />
        ) : (
          <View style={[styles.avatar, styles.placeholderCircle]} />
        );
      })()}
      <View style={{ flex: 1 }}>
        <Text style={{ fontWeight: 'bold' }}>{item.user?.name}</Text>
        <Text>{item.text}</Text>
        {/* Show comment timestamp below comment text */}
        {!!item.timestamp && (
          <Text style={styles.commentTimestamp}>{item.timestamp}</Text>
        )}
      </View>
    </View>
  );


  const handleSearch = (query) => {
    setSearchQuery(query);
  };

  // Pull to refresh handler
  const onRefresh = async () => {
    setRefreshing(true);
    try {
      setPage(1);
      await fetchPostsPage(1, false, accessToken, refreshToken);
      await fetchEvents(accessToken, refreshToken);
    } catch (err) {
      console.error('Refresh error:', err);
    } finally {
      setRefreshing(false);
    }
  };

  // Filter posts and events based on search query
  // Matches web React logic: combine posts (including announcement posts) and sort by datePosted
  const getFilteredData = () => {
    if (!searchQuery.trim()) {
      // Unified feed: all posts (regular + announcements) sorted by datePosted desc
      // Same as web: [...(announcements||[]), ...(posts||[])].sort((a,b) => datePosted desc)
      return posts
        .map(p => ({ 
          ...p, 
          itemType: p.isAnnouncement ? 'event' : 'post',
          sortDate: p.datePosted || p.timestamp || new Date(0).toISOString()
        }))
        .sort((a, b) => {
          const da = new Date(a.sortDate).getTime() || 0;
          const db = new Date(b.sortDate).getTime() || 0;
          return db - da; // newest first
        });
    }

    const query = searchQuery.toLowerCase().trim();
    
    // Filter posts by username, post text, or title (for announcements)
    const filteredPosts = posts.filter(p => 
      (p.user?.name && p.user.name.toLowerCase().includes(query)) ||
      (p.text && p.text.toLowerCase().includes(query)) ||
      (p.title && p.title.toLowerCase().includes(query))
    );

    return filteredPosts
      .map(p => ({ 
        ...p, 
        itemType: p.isAnnouncement ? 'event' : 'post',
        sortDate: p.datePosted || p.timestamp || new Date(0).toISOString()
      }))
      .sort((a, b) => {
        const da = new Date(a.sortDate).getTime() || 0;
        const db = new Date(b.sortDate).getTime() || 0;
        return db - da;
      });
  };

  const filteredData = getFilteredData();

  return (
    <SafeAreaView style={styles.container}>
      <Header title="HOME" showSearch={true} onSearch={handleSearch} />


      {error && <Text style={{ color: 'red', margin: 10 }}>{error}</Text>}


      {(role === "artist" || role === "admin") && (
        <TouchableOpacity style={styles.postOverlayBox} onPress={() => setModalVisible(true)}>
          {/* Show user's profile avatar if available; fallback keeps same size */}
  
          <Ionicons name="create-outline" size={24} color="#555" style={{ marginRight: 8 }} />
          <Text style={{ color: '#555' }}>Share inspiration, artwork or a thought</Text>
        </TouchableOpacity>
      )}


      <FlatList
        data={filteredData}
        keyExtractor={(item) => `${item.itemType}-${item.id || item.eventId}`}
        renderItem={({ item }) => item.itemType === 'event' ? renderEvent({ item }) : renderPost({ item })}
        contentContainerStyle={{ paddingBottom: 120 }}
        onEndReached={loadMore}
        onEndReachedThreshold={0.5}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={['#000']} // Android
            tintColor="#000" // iOS
          />
        }
        ListFooterComponent={
          isLoadingMore ? (
            <View style={{ paddingVertical: 20, alignItems: 'center' }}>
              <Text style={{ color: '#8b6f47', fontStyle: 'italic' }}>Loading more...</Text>
            </View>
          ) : !hasMore && filteredData.length > 0 ? (
            <View style={{ paddingVertical: 24, alignItems: 'center' }}>
              <Text style={{ color: '#8b6f47', fontStyle: 'italic' }}>You\'ve reached the end of the feed</Text>
            </View>
          ) : null
        }
        ListEmptyComponent={
          loading ? (
            <Text style={{ margin: 12 }}>Loading...</Text>
          ) : searchQuery.trim() ? (
            <View style={styles.noResults}>
              <Ionicons name="search-outline" size={64} color="#ccc" />
              <Text style={styles.noResultsTitle}>No results found</Text>
              <Text style={styles.noResultsText}>
                Try searching for different keywords
              </Text>
            </View>
          ) : null
        }
      />

      {/* Post options sheet (visible for owner/admin) */}
      <Modal
        visible={!!menuPost}
        animationType="fade"
        transparent
        onRequestClose={() => setMenuPost(null)}
      >
        <TouchableWithoutFeedback onPress={() => setMenuPost(null)}>
          <View style={styles.optionsOverlay}>
            <TouchableWithoutFeedback>
              <View style={styles.optionsSheet}>
                {(() => {
                  const isOwner = menuPost && (
                    role === 'admin' ||
                    (menuPost?.userId && menuPost.userId === currentUserId) ||
                    (menuPost?.user?.id && menuPost.user.id === currentUserId)
                  );
                  if (isOwner) {
                    return (
                      <>
                        <TouchableOpacity
                          style={styles.optionItem}
                          onPress={() => {
                            const p = menuPost;
                            setMenuPost(null);
                            setEditingPost(p);
                            setEditText(String(p?.text || ""));
                            // Initialize edit images from post
                            try {
                              let imgs = [];
                              if (Array.isArray(p?.image)) imgs = p.image;
                              else if (p?.image) imgs = [p.image];
                              else if (Array.isArray(p?.images)) imgs = p.images;
                              else if (p?.images) imgs = [p.images];
                              const safeImgs = (imgs || []).filter(Boolean);
                              setEditImages(safeImgs);
                              setOriginalEditImages(safeImgs);
                            } catch { setEditImages([]); }
                            setEditModalVisible(true);
                          }}
                        >
                          <Ionicons name="create-outline" size={18} color="#111" />
                          <Text style={styles.optionText}>Edit</Text>
                        </TouchableOpacity>
                        <TouchableOpacity
                          style={[styles.optionItem, styles.optionDanger]}
                          onPress={() => {
                            const postId = menuPost?.id;
                            setMenuPost(null);
                            if (!postId) return;
                            Alert.alert(
                              'Delete Post',
                              'Are you sure you want to delete this post? This action cannot be undone.',
                              [
                                { text: 'Cancel', style: 'cancel' },
                                { text: 'Delete', style: 'destructive', onPress: async () => {
                                    try {
                                      const res = await fetch(`${API_BASE}/homepage/posts/${postId}`, {
                                        method: 'DELETE',
                                        headers: { 'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}` },
                                      });
                                      if (!res.ok) {
                                        let msg = 'Failed to delete post';
                                        try { const j = await res.json(); if (j?.error || j?.message) msg = String(j.error || j.message); } catch {}
                                        throw new Error(msg);
                                      }
                                      await fetchPosts();
                                    } catch (e) {
                                      Alert.alert('Error', e?.message || 'Failed to delete post');
                                    }
                                  } },
                              ]
                            );
                          }}
                        >
                          <Ionicons name="trash-outline" size={18} color="#b91c1c" />
                          <Text style={[styles.optionText, { color: '#b91c1c' }]}>Delete</Text>
                        </TouchableOpacity>
                      </>
                    );
                  }
                  // Non-owner view: show Report only
                  return (
                    <TouchableOpacity
                      style={styles.optionItem}
                      onPress={() => {
                        const postId = menuPost?.id;
                        setMenuPost(null);
                        if (postId) handleReport(postId);
                      }}
                    >
                      <Ionicons name="flag-outline" size={18} color="#111" />
                      <Text style={styles.optionText}>Report</Text>
                    </TouchableOpacity>
                  );
                })()}
              </View>
            </TouchableWithoutFeedback>
          </View>
        </TouchableWithoutFeedback>
      </Modal>


      {/* Image fullscreen modal with carousel */}
      <Modal
        visible={selectedImage !== null && selectedImages.length > 0}
        transparent
        animationType="fade"
        onRequestClose={() => {
          setSelectedImage(null);
          setSelectedImages([]);
          setCurrentImageIndex(0);
        }}
      >
        <View style={styles.fullScreenContainer}>
          {/* Close button */}
          <TouchableOpacity 
            style={{
              position: 'absolute',
              top: 40,
              right: 20,
              zIndex: 10,
              backgroundColor: 'rgba(0,0,0,0.5)',
              borderRadius: 20,
              width: 40,
              height: 40,
              justifyContent: 'center',
              alignItems: 'center',
            }}
            onPress={() => {
              setSelectedImage(null);
              setSelectedImages([]);
              setCurrentImageIndex(0);
            }}
          >
            <Ionicons name="close" size={24} color="white" />
          </TouchableOpacity>

          {/* Image counter */}
          {selectedImages.length > 1 && (
            <View style={{
              position: 'absolute',
              top: 40,
              left: 20,
              zIndex: 10,
              backgroundColor: 'rgba(0,0,0,0.7)',
              paddingHorizontal: 12,
              paddingVertical: 6,
              borderRadius: 16,
            }}>
              <Text style={{ color: 'white', fontSize: 14, fontWeight: 'bold' }}>
                {currentImageIndex + 1}/{selectedImages.length}
              </Text>
            </View>
          )}

          {/* Swipeable image carousel */}
          <FlatList
            data={selectedImages}
            horizontal
            pagingEnabled
            showsHorizontalScrollIndicator={false}
            keyExtractor={(item, index) => index.toString()}
            onMomentumScrollEnd={(event) => {
              const index = Math.round(event.nativeEvent.contentOffset.x / event.nativeEvent.layoutMeasurement.width);
              setCurrentImageIndex(index);
            }}
            renderItem={({ item }) => (
              <View style={{ width: SCREEN_WIDTH, justifyContent: 'center', alignItems: 'center' }}>
                <Image source={item} style={styles.fullScreenImage} resizeMode="contain" />
              </View>
            )}
          />
        </View>
      </Modal>


      {/* Create Post modal */}
      <Modal visible={modalVisible} transparent animationType="slide" onRequestClose={() => setModalVisible(false)}>
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Create Post</Text>
                <TouchableOpacity onPress={() => setModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
                {/* User Avatar and Text Input */}
                <View style={styles.postInputContainer}>
                  {image ? (
                    <Image source={image} style={styles.postAvatar} />
                  ) : (
                    <View style={[styles.postAvatar, styles.placeholderCircle]}>
                      <Ionicons name="person" size={24} color="#999" />
                    </View>
                  )}
                  <TextInput
                    style={styles.postTextInput}
                    placeholder="What's on your mind?"
                    placeholderTextColor="#999"
                    value={postText}
                    onChangeText={setPostText}
                    multiline
                    numberOfLines={4}
                  />
                </View>

                {/* Photos (Optional) */}
                <Text style={styles.uploadInputLabel}>Photos (Optional)</Text>
                <ScrollView 
                  horizontal 
                  showsHorizontalScrollIndicator={false}
                  style={{ marginBottom: 16 }}
                >
                  {pickedImages.map((item, index) => (
                    <View key={index} style={styles.postImageContainer}>
                      <Image
                        source={{ uri: Array.isArray(item) ? item[0] : item }}
                        style={styles.postPreviewImage}
                      />
                      <TouchableOpacity onPress={() => removeImage(index)} style={styles.postRemoveBtn}>
                        <Ionicons name="close-circle" size={26} color="#fff" />
                      </TouchableOpacity>
                    </View>
                  ))}
                  <View style={styles.postImageContainer}>
                    <TouchableOpacity onPress={pickImage} style={styles.postAddPhotoBtn}>
                      <Ionicons name="image-outline" size={32} color="#A68C7B" />
                      <Text style={styles.postAddPhotoText}>Add Photo</Text>
                    </TouchableOpacity>
                  </View>
                </ScrollView>

                {/* Post Button */}
                <TouchableOpacity style={styles.uploadButton} onPress={uploadPost}>
                  <Text style={styles.uploadButtonText}>Post</Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>


      {/* Edit Post modal */}
      <Modal visible={editModalVisible} transparent animationType="slide" onRequestClose={() => setEditModalVisible(false)}>
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Edit Post</Text>
                <TouchableOpacity onPress={() => setEditModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
                <View style={styles.postInputContainer}>
                  {(() => {
                    const avatarUri = ensureUri(image?.uri || editingPost?.user?.avatar);
                    return avatarUri ? (
                      <Image source={{ uri: avatarUri }} style={styles.postAvatar} />
                    ) : (
                      <View style={[styles.postAvatar, styles.placeholderCircle]}>
                        <Ionicons name="person" size={24} color="#999" />
                      </View>
                    );
                  })()}
                  <TextInput
                    style={styles.postTextInput}
                    placeholder="Update your post text"
                    placeholderTextColor="#999"
                    value={editText}
                    onChangeText={setEditText}
                    multiline
                    numberOfLines={4}
                  />
                </View>

                {/* Photos (Optional) - same UI as create modal, but for editing */}
                <Text style={styles.uploadInputLabel}>Photos (Optional)</Text>
                <ScrollView 
                  horizontal 
                  showsHorizontalScrollIndicator={false}
                  style={{ marginBottom: 16 }}
                >
                  {editImages.map((uri, index) => (
                    <View key={index} style={styles.postImageContainer}>
                      <Image
                        source={{ uri: Array.isArray(uri) ? uri[0] : uri }}
                        style={styles.postPreviewImage}
                      />
                      <TouchableOpacity onPress={() => removeEditImage(index)} style={styles.postRemoveBtn}>
                        <Ionicons name="close-circle" size={26} color="#fff" />
                      </TouchableOpacity>
                    </View>
                  ))}
                  {editImages.length < 4 && (
                    <View style={styles.postImageContainer}>
                      <TouchableOpacity onPress={pickEditImage} style={styles.postAddPhotoBtn}>
                        <Ionicons name="image-outline" size={32} color="#A68C7B" />
                        <Text style={styles.postAddPhotoText}>Add Photo</Text>
                      </TouchableOpacity>
                    </View>
                  )}
                </ScrollView>

                <TouchableOpacity style={[styles.uploadButton, { opacity: editSaving ? 0.6 : 1 }]} onPress={saveEditPost} disabled={editSaving}>
                  <Text style={styles.uploadButtonText}>{editSaving ? 'Saving...' : 'Save Changes'}</Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>


      {/* Comments Modal */}
      <Modal visible={commentModalVisible} animationType="slide">
        <SafeAreaView style={styles.container}>
          <KeyboardAvoidingView
            behavior={Platform.OS === "ios" ? "padding" : "height"}
            style={{ flex: 1 }}
            keyboardVerticalOffset={Platform.OS === "ios" ? 0 : 20}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center', padding: 10 }}>
              <TouchableOpacity onPress={() => setCommentModalVisible(false)}>
                <Ionicons name="arrow-back" size={24} color="#000" />
              </TouchableOpacity>
              <Text style={{ fontSize: 18, fontWeight: 'bold', marginLeft: 10 }}>Comments</Text>
            </View>
            <FlatList
              data={currentPostComments}
              keyExtractor={(item) => item.id.toString()}
              renderItem={renderComment}
              ListEmptyComponent={
                <View style={styles.emptyCommentsContainer}>
                  <Ionicons name="chatbubbles-outline" size={64} color="#A68C7B" style={{ marginBottom: 12 }} />
                  <Text style={styles.emptyCommentsText}>No comments yet</Text>
                  <Text style={styles.emptyCommentsSubtext}>Be the first to comment!</Text>
                </View>
              }
              contentContainerStyle={currentPostComments.length === 0 ? { flex: 1 } : {}}
            />
            <View style={styles.commentInputContainer}>
              <TextInput
                style={styles.commentInput}
                placeholder="Add a comment..."
                value={newCommentText}
                onChangeText={setNewCommentText}
              />
              <TouchableOpacity onPress={postComment} style={styles.sendButton}>
                <Ionicons name="send" size={20} color="white" />
              </TouchableOpacity>
            </View>
          </KeyboardAvoidingView>
        </SafeAreaView>
      </Modal>


      {/* Complete Your Profile Modal */}
      <Modal visible={profileModalVisible} animationType="slide" transparent onRequestClose={() => setProfileModalVisible(false)}>
        <KeyboardAvoidingView 
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
          style={{ flex: 1 }}
        >
          <View style={styles.uploadModalOverlay}>
            <View style={styles.uploadModalContent}>
              <View style={styles.uploadModalHeader}>
                <Text style={styles.uploadModalTitle}>Complete Your Profile</Text>
                <TouchableOpacity onPress={() => setProfileModalVisible(false)}>
                  <Ionicons name="close" size={24} color="#333" />
                </TouchableOpacity>
              </View>

              <ScrollView style={styles.uploadModalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
                <Text style={styles.uploadInputLabel}>Profile Photo</Text>
                <TouchableOpacity onPress={pickProfileImage} style={styles.uploadImagePicker}>
                  {tempImage ? (
                    <Image source={tempImage} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="person-circle-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to add profile photo</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>Cover Photo</Text>
                <TouchableOpacity onPress={pickBackgroundImage} style={styles.uploadImagePicker}>
                  {tempBackgroundImage ? (
                    <Image source={{ uri: tempBackgroundImage.uri }} style={styles.uploadPickedImage} />
                  ) : (
                    <View style={styles.uploadImagePlaceholder}>
                      <Ionicons name="image-outline" size={48} color="#A68C7B" />
                      <Text style={styles.uploadImageText}>Tap to add cover photo</Text>
                    </View>
                  )}
                </TouchableOpacity>

                <Text style={styles.uploadInputLabel}>First Name</Text>
                <TextInput style={styles.uploadInput} placeholder="First Name" value={firstName} onChangeText={setFirstName} />

                <Text style={styles.uploadInputLabel}>Middle Name</Text>
                <TextInput style={styles.uploadInput} placeholder="Middle Name" value={middleName} onChangeText={setMiddleName} />

                <Text style={styles.uploadInputLabel}>Last Name</Text>
                <TextInput style={styles.uploadInput} placeholder="Last Name" value={lastName} onChangeText={setLastName} />

                <Text style={styles.uploadInputLabel}>Username</Text>
                <TextInput style={styles.uploadInput} placeholder="Username" value={userNameField} onChangeText={setUserNameField} />

                <Text style={styles.uploadInputLabel}>Sex</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setShowSexDropdown(!showSexDropdown)}>
                  <Text style={{ color: sex ? "#000" : "#999" }}>{sex || "Select Sex"}</Text>
                  <Ionicons name={showSexDropdown ? "chevron-up" : "chevron-down"} size={20} color="#555" style={{ position: "absolute", right: 12, top: 12 }} />
                </TouchableOpacity>
                {showSexDropdown && (
                  <View style={styles.categoryDropdown}>
                    {["Male", "Female", "PreferNotToSay"].map((item) => (
                      <TouchableOpacity key={item} style={styles.categoryItem} onPress={() => { setSex(item); setShowSexDropdown(false); }}>
                        <Text style={styles.categoryItemText}>{item}</Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                )}

                <Text style={styles.uploadInputLabel}>Birthday</Text>
                <TouchableOpacity style={styles.uploadInput} onPress={() => setShowDatePicker(true)}>
                  <Text style={{ color: birthday ? "#000" : "#999" }}>
                    {birthday ? formattedDate : "Select your birthday"}
                  </Text>
                </TouchableOpacity>
                {showDatePicker && (
                  <DateTimePicker value={birthday} mode="date" display="default" onChange={onChangeDate} />
                )}

                <Text style={styles.uploadInputLabel}>Address</Text>
                <TextInput style={styles.uploadInput} placeholder="Enter your address" value={address} onChangeText={setAddress} />

                <Text style={styles.uploadInputLabel}>Bio</Text>
                <TextInput style={styles.uploadInput} placeholder="Enter your bio" value={bio} onChangeText={setBio} />

                <Text style={styles.uploadInputLabel}>About</Text>
                <TextInput style={[styles.uploadInput, styles.uploadTextArea]} placeholder="Write something about yourself" multiline value={about} onChangeText={setAbout} />

                <TouchableOpacity style={styles.uploadButton} onPress={handleProfileSave}>
                  <Text style={styles.uploadButtonText}>Save Profile</Text>
                </TouchableOpacity>
              </ScrollView>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>

      {/* Art Interests Modal */}
      <Modal visible={interestsModalVisible} animationType="fade" transparent>
        <TouchableWithoutFeedback>
          <View style={styles.modalOverlay}>
            <View style={styles.interestsBox}>
              <Text style={styles.modalTitle}>Choose Your Art Interests</Text>
              <Text style={{ marginBottom: 10, color: '#555', textAlign: 'center' }}>Pick a few to personalize your feed</Text>
              <ScrollView style={{ maxHeight: 400 }} showsVerticalScrollIndicator={false}>
                <View style={styles.interestsGrid}>
                {[
                  { id: 'classical', name: 'Classical Art', color: '#111' },
                  { id: 'contemporary', name: 'Contemporary', color: '#6b21a8' },
                  { id: 'impressionist', name: 'Impressionist', color: '#b45309' },
                  { id: 'abstract', name: 'Abstract', color: '#047857' },
                  { id: 'sculpture', name: 'Sculpture', color: '#1f2937' },
                  { id: 'photography', name: 'Photography', color: '#0ea5e9' },
                  { id: 'digital', name: 'Digital Art', color: '#7c3aed' },
                  { id: 'street', name: 'Street Art', color: '#f59e0b' },
                  { id: 'minimalist', name: 'Minimalist', color: '#4b5563' },
                  { id: 'surrealist', name: 'Surrealist', color: '#ef4444' },
                  { id: 'landscape', name: 'Landscape', color: '#10b981' },
                  { id: 'portrait', name: 'Portrait', color: '#60a5fa' },
                  { id: 'miniature', name: 'Miniature', color: '#f59e0b' },
                  { id: 'expressionist', name: 'Expressionist', color: '#ef4444' },
                  { id: 'realism', name: 'Realism', color: '#10b981' },
                  { id: 'conceptual', name: 'Conceptual', color: '#0ea5e9' },
                ].map((cat) => {
                  const selected = selectedInterests.includes(cat.id);
                  return (
                    <TouchableOpacity
                      key={cat.id}
                      activeOpacity={0.8}
                      onPress={() => {
                        setSelectedInterests((prev) =>
                          prev.includes(cat.id)
                            ? prev.filter((x) => x !== cat.id)
                            : [...prev, cat.id]
                        );
                      }}
                      style={[styles.categoryCard, selected && { borderColor: cat.color, backgroundColor: '#f9fafb' }]}
                    >
                      <View style={[styles.categoryDot, { backgroundColor: cat.color }]} />
                      <Text style={[styles.categoryText, selected && { color: cat.color }]} numberOfLines={1}>
                        {cat.name}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
                </View>
                {!!selectedInterests.length && (
                  <Text style={{ marginTop: 6, marginBottom: 10, color: '#111', fontWeight: '600', textAlign: 'center' }}>
                    {selectedInterests.length} selected
                  </Text>
                )}
              </ScrollView>
              <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginTop: 15, gap: 10 }}>
                <TouchableOpacity
                  style={[styles.cancelButton, { flex: 1, alignItems: 'center', justifyContent: 'center' }]}
                  onPress={() => setInterestsModalVisible(false)}
                >
                  <Text style={styles.cancelButtonText}>Maybe later</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={[styles.saveButton, { flex: 1, backgroundColor: '#A68C7B', opacity: selectedInterests.length ? 1 : 0.5, alignItems: 'center', justifyContent: 'center' }]}
                  disabled={!selectedInterests.length}
                  onPress={async () => {
                    const preferences = {
                      classicalArt: selectedInterests.includes('classical'),
                      contemporaryArt: selectedInterests.includes('contemporary'),
                      impressionist: selectedInterests.includes('impressionist'),
                      abstractArt: selectedInterests.includes('abstract'),
                      sculpture: selectedInterests.includes('sculpture'),
                      photography: selectedInterests.includes('photography'),
                      digitalArt: selectedInterests.includes('digital'),
                      streetArt: selectedInterests.includes('street'),
                      minimalist: selectedInterests.includes('minimalist'),
                      surrealist: selectedInterests.includes('surrealist'),
                      landscape: selectedInterests.includes('landscape'),
                      portrait: selectedInterests.includes('portrait'),
                      miniature: selectedInterests.includes('miniature'),
                      expressionist: selectedInterests.includes('expressionist'),
                      realism: selectedInterests.includes('realism'),
                      conceptual: selectedInterests.includes('conceptual'),
                    };
                    try {
                      const res = await fetch(`${API_BASE}/profile/saveArtPreferences`, {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json',
                          'Cookie': `access_token=${accessToken}; refresh_token=${refreshToken}`,
                        },
                        credentials: 'include',
                        body: JSON.stringify(preferences),
                      });
                      if (!res.ok) {
                        let errMsg = `Failed to save preferences (${res.status})`;
                        try {
                          const txt = await res.text();
                          try {
                            const j = txt ? JSON.parse(txt) : null;
                            if (j && (j.message || j.error)) errMsg = `${errMsg}: ${j.message || j.error}`;
                            else if (txt) errMsg = `${errMsg}: ${txt}`;
                          } catch {
                            if (txt) errMsg = `${errMsg}: ${txt}`;
                          }
                        } catch {}
                        throw new Error(errMsg);
                      }
                      setHasArtPreferences(true);
                      setInterestsModalVisible(false);
                    } catch (e) {
                      console.log('saveArtPreferences error:', e?.message || e);
                      alert(e?.message || 'Failed to save preferences');
                    }
                  }}
                >
                  <Text style={styles.saveButtonText}>Continue</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </TouchableWithoutFeedback>
      </Modal>

      <AndroidFooterSpacer />
    </SafeAreaView>
  );
};


const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff' },
  postOverlayBox: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    marginHorizontal: 12,
    borderRadius: 12,
    borderWidth: 0.8,
    borderColor: '#ccc',
    backgroundColor: '#f9f9f9',
    marginBottom: 10,
  },
  avatar: { width: 40, height: 40, borderRadius: 20, marginRight: 8 },
  modalBackground: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'center',
    paddingHorizontal: 20,
  },
  modalCard: {
    backgroundColor: '#fff',
    borderRadius: 15,
    padding: 15,
    shadowColor: 'black',
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 5,
  },
  modalInputBox: { flexDirection: 'row', alignItems: 'flex-start', marginBottom: 10 },
  modalInput: {
    flex: 1,
    backgroundColor: '#f0f2f5',
    borderRadius: 20,
    paddingHorizontal: 12,
    paddingVertical: 10,
    minHeight: 40,
    maxHeight: 120,
    color: '#000',
  },
  previewImage: { width: 90, height: 90, borderRadius: 12 },
  removeImageBtn: {
    position: 'absolute',
    top: 1,
    right: -4,
    width: 26,
    height: 26,
    borderRadius: 13,
    backgroundColor: 'black',
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 3,
    zIndex: 10,
  },
  addMoreBtn: {
    width: 90,
    height: 90,
    borderRadius: 12,
    borderWidth: 1.5,
    borderColor: 'black',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 10,
  },
  addPhotoText: { color: 'black', fontSize: 12, marginTop: 4, fontWeight: '600' },
  postButton: { backgroundColor: '#A68C7B', paddingVertical: 12, borderRadius: 25, alignItems: 'center', marginTop: 5 },
  postButtonText: { color: '#fff', fontWeight: 'bold', fontSize: 16 },
  card: {
    backgroundColor: 'white',
    borderRadius: 10,
    padding: 10,
    marginBottom: 12,
    marginHorizontal: 10,
    shadowColor: 'black',
    shadowOpacity: 0.09,
    shadowRadius: 4,
    elevation: 2,
  },
  userInfo: { flexDirection: 'row', alignItems: 'center', marginBottom: 5 },
  username: { fontWeight: 'bold' },
  moreBtn: { marginLeft: 'auto', paddingHorizontal: 8, paddingVertical: 4 },
  description: { marginBottom: 8 },
  timestamp: {
    color: '#999',
    fontSize: 12,
    marginTop: 4,
    marginBottom: 4,
  },
  postImage: { width: '100%', height: 180, borderRadius: 8, marginBottom: 10 },
  actions: { flexDirection: 'row', alignItems: 'center', marginTop: 8 },
  likeContainer: { flexDirection: 'row', alignItems: 'center', marginRight: 12 },
  likeText: { marginLeft: 4, color: 'red' },
  fullScreenContainer: { flex: 1, backgroundColor: 'rgba(0,0,0,0.95)', justifyContent: 'center', alignItems: 'center' },
  fullScreenImage: { width: '100%', height: '100%' },
  commentBox: { flexDirection: 'row', padding: 10, borderBottomWidth: 1, borderColor: '#eee' },
  commentTimestamp: {
    fontSize: 10,
    color: '#999',
    marginTop: 2,
  },
  commentInputContainer: { flexDirection: 'row', padding: 10, borderTopWidth: 1, borderColor: '#eee' },
  commentInput: { flex: 1, backgroundColor: '#f0f2f5', borderRadius: 20, paddingHorizontal: 12 },
  sendButton: { backgroundColor: '#A68C7B', borderRadius: 20, padding: 10, marginLeft: 8 },
  emptyCommentsContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  emptyCommentsText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#A68C7B',
    marginBottom: 4,
  },
  emptyCommentsSubtext: {
    fontSize: 14,
    color: '#999',
  },


  modalOverlay: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "rgba(0,0,0,0.4)",
  },
  keyboardView: { flex: 1, width: "100%" },
  modalBox: {
    backgroundColor: "#fff",
    padding: 20,
    borderRadius: 15,
    elevation: 5,
    alignItems: "center",
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: "bold",
    marginTop: 30,
    marginBottom: 15,
  },
  imagePicker: { alignItems: "center", marginVertical: 10 },
  avatarEdit: { width: 90, height: 90, borderRadius: 45 },
  changePhotoText: {
    textAlign: "center",
    color: "#007BFF",
    marginTop: 5,
    marginBottom: 10,
  },
  input: {
    backgroundColor: "#f9f9f9",
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 10,
    padding: 10,
    marginVertical: 5,
    width: "100%",
  },
  inputContainer: {
    width: "100%",
    position: "relative",
  },
  dropdownList: {
    width: "100%",
    backgroundColor: "#fff",
    borderWidth: 1,
    borderColor: "#ccc",
    borderRadius: 10,
    marginTop: -5,
    elevation: 3,
    zIndex: 10,
  },
  dropdownItem: {
    paddingVertical: 12,
    paddingHorizontal: 10,
    borderBottomWidth: 1,
    borderBottomColor: "#eee",
  },
  dropdownItemText: {
    fontSize: 16,
    color: "#000",
  },
  modalButtons: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 15,
    width: "100%",
  },
  saveButton: {
    backgroundColor: "#A68C7B",
    paddingVertical: 8,
    paddingHorizontal: 25,
    borderRadius: 20,
  },
  saveButtonText: { color: "#fff", fontWeight: "bold" },
  cancelButton: {
    backgroundColor: "#eee",
    paddingVertical: 8,
    paddingHorizontal: 25,
    borderRadius: 20,
  },
  cancelButtonText: { color: "black", fontWeight: "bold" },
  placeholderCircle: {
    backgroundColor: "#f0f0f0",
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#ddd",
  },
  backgroundPreviewContainer: {
    width: 300,
    height: 100,
    borderRadius: 10,
    overflow: "hidden",
    backgroundColor: "#f0f0f0",
    justifyContent: "center",
    alignItems: "center",
    alignSelf: "center",
  },
  backgroundPreviewImage: {
    width: "100%",
    height: "100%",
  },
  eventCard: {
    shadowColor: 'black',
    shadowOpacity: 0.09,
    shadowRadius: 4,
    elevation: 2,
  },
  eventBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    alignSelf: 'flex-start',
    backgroundColor: '#000',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
    marginBottom: 8,
  },
  eventBadgeText: {
    color: '#fff',
    fontSize: 12,
    fontWeight: 'bold',
    marginLeft: 4,
  },
  eventTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#000',
    marginBottom: 8,
  },
  eventMetaContainer: {
    marginTop: 8,
    marginBottom: 8,
  },
  eventMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
  },
  eventMetaText: {
    fontSize: 14,
    color: '#555',
    marginLeft: 6,
    flex: 1,
  },
  eventViewMore: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingTop: 8,
    borderTopWidth: 1,
    borderTopColor: '#eee',
    marginTop: 8,
  },
  eventViewMoreText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#000',
    marginRight: 4,
  },
  noResults: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 60,
    paddingHorizontal: 20,
  },
  noResultsTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 16,
    marginBottom: 8,
  },
  noResultsText: {
    fontSize: 14,
    color: '#999',
    textAlign: 'center',
  },
  optionsOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.4)',
    justifyContent: 'flex-end',
  },
  optionsSheet: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    paddingVertical: 8,
    paddingBottom: 24,
  },
  optionItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 16,
    paddingVertical: 14,
  },
  optionText: { marginLeft: 10, fontSize: 16, color: '#111' },
  optionDanger: { borderTopWidth: 1, borderTopColor: '#eee' },
  interestsBox: {
    backgroundColor: '#fff',
    padding: 20,
    borderRadius: 20,
    width: '90%',
    maxHeight: '80%',
    elevation: 10,
    shadowColor: '#000',
    shadowOpacity: 0.3,
    shadowRadius: 10,
  },
  interestsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-between',
    gap: 10,
  },
  categoryCard: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 20,
    borderWidth: 2,
    borderColor: '#e5e7eb',
    backgroundColor: '#fff',
    width: '48%',
    marginBottom: 8,
  },
  categoryDot: {
    width: 10,
    height: 10,
    borderRadius: 5,
    marginRight: 8,
  },
  categoryText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#374151',
    flex: 1,
  },
  uploadModalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  uploadModalContent: {
    backgroundColor: '#fff',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    maxHeight: '90%',
  },
  uploadModalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e0e0e0',
  },
  uploadModalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#A68C7B',
  },
  uploadModalBody: {
    padding: 20,
  },
  uploadInputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  uploadButton: {
    backgroundColor: '#A68C7B',
    paddingVertical: 15,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  uploadButtonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: 'bold',
  },
  postInputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 20,
  },
  postAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    marginRight: 12,
  },
  postTextInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 12,
    fontSize: 14,
    minHeight: 100,
    textAlignVertical: 'top',
  },
  postImageContainer: {
    position: 'relative',
    marginRight: 10,
    paddingTop: 10,
    paddingRight: 10,
  },
  postPreviewImage: {
    width: 100,
    height: 100,
    borderRadius: 8,
  },
  postRemoveBtn: {
    position: 'absolute',
    top: 0,
    right: 0,
    backgroundColor: 'rgba(0,0,0,0.7)',
    borderRadius: 13,
  },
  postAddPhotoBtn: {
    width: 100,
    height: 100,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#A68C7B',
    borderStyle: 'dashed',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
  },
  postAddPhotoText: {
    fontSize: 12,
    color: '#A68C7B',
    marginTop: 4,
  },
  uploadImagePicker: {
    width: '100%',
    height: 200,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#A68C7B',
    borderStyle: 'dashed',
    marginBottom: 20,
    overflow: 'hidden',
  },
  uploadImagePlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f9f9f9',
  },
  uploadImageText: {
    marginTop: 10,
    fontSize: 14,
    color: '#A68C7B',
  },
  uploadPickedImage: {
    width: '100%',
    height: '100%',
    resizeMode: 'cover',
  },
  uploadInput: {
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    padding: 12,
    fontSize: 14,
    marginBottom: 16,
    backgroundColor: '#fff',
  },
  uploadTextArea: {
    height: 100,
    textAlignVertical: 'top',
  },
  categoryDropdown: {
    backgroundColor: '#fff',
    borderWidth: 1,
    borderColor: '#e0e0e0',
    borderRadius: 8,
    marginTop: -8,
    marginBottom: 16,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  categoryItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f0f0f0',
  },
  categoryItemText: {
    fontSize: 14,
    color: '#333',
  },
});


export default HomeScreen;
